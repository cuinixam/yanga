import json
from pathlib import Path
from unittest.mock import Mock

import pytest
from py_app_dev.core.data_registry import DataRegistry
from py_app_dev.core.pipeline import PipelineStepConfig

from tests.utils import assert_element_of_type, write_file
from yanga.cmake.builder import CMakeBuildSystemGenerator
from yanga.cmake.cmake_backend import CMakeComment
from yanga.docs.sphinx import SphinxReportConfig
from yanga.domain.config import PlatformConfig
from yanga.domain.execution_context import ExecutionContext, UserRequest, UserRequestScope, UserRequestTarget
from yanga.domain.reports import ComponentReportData, ReportRelevantFiles, ReportRelevantFileType


@pytest.fixture
def env(tmp_path: Path) -> ExecutionContext:
    env = Mock(spec=ExecutionContext)
    env.project_root_dir = tmp_path
    env.variant_name = "mock_variant"
    env.create_artifacts_locator = Mock()
    env.data_registry = DataRegistry()
    env.platform = None
    return env


@pytest.fixture
def env_with_platform(tmp_path: Path) -> ExecutionContext:
    env = Mock(spec=ExecutionContext)
    env.project_root_dir = tmp_path
    env.variant_name = "mock_variant"
    env.create_artifacts_locator = Mock()
    env.data_registry = DataRegistry()
    env.platform = Mock()
    env.platform.name = "test_platform"
    return env


def test_create_variant_cmake_file(env: ExecutionContext) -> None:
    output_dir = env.project_root_dir / "output"
    write_file(
        Path(env.project_root_dir, "tools/my_cmake_generator.py"),
        """
from pathlib import Path
from typing import Dict, List

from yanga.domain.execution_context import (
    ExecutionContext,
)

from yanga.cmake.cmake_backend import (
    CMakeComment,
    CMakeElement,
)
from yanga.cmake.generator import CMakeGenerator


class MyCMakeGenerator(CMakeGenerator):
    def __init__(self, execution_context: ExecutionContext, output_dir: Path, config: Dict) -> None:
        super().__init__(execution_context, output_dir, config)

    def generate(self) -> list[CMakeElement]:
        elements: list[CMakeElement] = []
        elements.append(CMakeComment(f"Generated by {self.__class__.__name__}"))
        return elements

""",
    )
    env.platform = PlatformConfig(
        name="MockPlatfrom",
        cmake_generators=[
            PipelineStepConfig(
                step="MyCMakeGenerator",
                file="tools/my_cmake_generator.py",
            )
        ],
    )
    generator = CMakeBuildSystemGenerator(env, output_dir)
    cmake_file = generator.create_variant_cmake_file()
    assert cmake_file.path == output_dir / "variant.cmake"
    assert "# Generated by MyCMakeGenerator" == assert_element_of_type(cmake_file.content, CMakeComment).to_string()


def test_create_report_config_file_empty_registry(env: ExecutionContext) -> None:
    """Test creating report config file when no ReportRelevantFiles are registered."""
    output_dir = env.project_root_dir / "output"
    generator = CMakeBuildSystemGenerator(env, output_dir)

    generated_file = generator.create_report_config_file()

    assert generated_file.path == output_dir / "report_config.json"

    # Parse the generated JSON to verify structure
    import json

    config_data = json.loads(generated_file.to_string())

    assert config_data["variant_name"] == "mock_variant"
    assert config_data["platform_name"] == ""
    assert config_data["components"] == []


def test_create_report_config_file_with_components(env_with_platform: ExecutionContext) -> None:
    """Test creating report config file with ReportRelevantFiles for multiple components."""
    output_dir = env_with_platform.project_root_dir / "output"
    generator = CMakeBuildSystemGenerator(env_with_platform, output_dir)

    # Register some test data in the data registry
    component1_docs_target = UserRequest(
        UserRequestScope.COMPONENT,
        target=UserRequestTarget.DOCS,
        component_name="component1",
    )
    component1_report_target = UserRequest(
        UserRequestScope.COMPONENT,
        target=UserRequestTarget.REPORT,
        component_name="component1",
    )
    component2_test_target = UserRequest(
        UserRequestScope.COMPONENT,
        target=UserRequestTarget.TEST,
        component_name="component2",
    )

    # Register different types of files for component1
    env_with_platform.data_registry.insert(
        ReportRelevantFiles(
            target=component1_docs_target,
            file_type=ReportRelevantFileType.DOCS,
            files_to_be_included=[Path("component1/docs/file1.md"), Path("component1/docs/file2.md")],
        ),
        "test_provider",
    )

    env_with_platform.data_registry.insert(
        ReportRelevantFiles(
            target=component1_report_target,
            file_type=ReportRelevantFileType.SOURCES,
            files_to_be_included=[Path("component1/src/main.cpp"), Path("component1/src/utils.cpp")],
        ),
        "test_provider",
    )

    # Register test results for component2
    env_with_platform.data_registry.insert(
        ReportRelevantFiles(
            target=component2_test_target,
            file_type=ReportRelevantFileType.TEST_RESULT,
            files_to_be_included=[Path("component2/test_results.xml")],
        ),
        "test_provider",
    )

    # Register a variant-scoped entry (should be ignored)
    variant_target = UserRequest(
        UserRequestScope.VARIANT,
        target=UserRequestTarget.REPORT,
    )
    env_with_platform.data_registry.insert(
        ReportRelevantFiles(
            target=variant_target,
            file_type=ReportRelevantFileType.OTHER,
            files_to_be_included=[Path("variant_file.txt")],
        ),
        "test_provider",
    )

    generated_file = generator.create_report_config_file()

    config_data = SphinxReportConfig.from_dict(json.loads(generated_file.to_string()))

    assert config_data.variant_name == "mock_variant"
    assert config_data.platform_name == "test_platform"
    assert len(config_data.components) == 2

    # Find component1 and component2 in the config
    component1_config = assert_element_of_type(config_data.components, ComponentReportData, lambda c: c.name == "component1")

    # Check component1 has docs and component sources
    assert set(component1_config.docs_files) == {Path("component1/docs/file1.md"), Path("component1/docs/file2.md")}
    assert set(component1_config.sources) == {Path("component1/src/main.cpp"), Path("component1/src/utils.cpp")}

    component2_config = assert_element_of_type(config_data.components, ComponentReportData, lambda c: c.name == "component2")
    assert set(component2_config.test_results) == {Path("component2/test_results.xml")}

    # Verify other fields are empty lists for both components
    for config in [component1_config, component2_config]:
        for field in ["lint_results", "coverage_results", "other_files"]:
            assert config.__getattribute__(field) == []
